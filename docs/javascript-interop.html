<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Razor Components JavaScript interop </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Razor Components JavaScript interop ">
    <meta name="generator" content="docfx 2.40.7.0">
    
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../styles/docfx.css">
    <link rel="stylesheet" href="../styles/main.css">
    <meta property="docfx:navrel" content="../toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../index.html">
                <img id="logo" class="svg" src="../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="razor-components/javascript-interop">
<h1 id="razor-components-javascript-interop">Razor Components JavaScript interop</h1>

<p>By <a href="https://github.com/javiercn">Javier Calvarro Nelson</a>, <a href="https://github.com/danroth27">Daniel Roth</a>, and <a href="https://github.com/guardrex">Luke Latham</a></p>
<div class="NOTE"><h5>Note</h5><p>ASP.NET Core Razor Components is supported in ASP.NET Core 3.0 or later.</p>
<p>Blazor is an unsupported experimental web framework that shouldn&#39;t be used for production workloads at this time.</p>
</div>
<p>A Razor Components app can invoke JavaScript functions from .NET and .NET methods from JavaScript code.</p>
<h2 id="invoke-javascript-functions-from-net-methods">Invoke JavaScript functions from .NET methods</h2>
<p>There are times when .NET code is required to call a JavaScript function. For example, a JavaScript call can expose browser capabilities or functionality from a JavaScript library to the app.</p>
<p>To call into JavaScript from .NET, use the <code>IJSRuntime</code> abstraction. The <code>InvokeAsync&lt;T&gt;</code> method on <code>IJSRuntime</code> takes an identifier for the JavaScript function you wish to invoke along with any number of JSON-serializable arguments. The function identifier is relative to the global scope (<code>window</code>). If you wish to call <code>window.someScope.someFunction</code>, the identifier is <code>someScope.someFunction</code>. There&#39;s no need to register the function before it&#39;s called. The return type <code>T</code> must also be JSON serializable.</p>
<p>For server-side ASP.NET Core Razor Components apps:</p>
<ul>
<li>Multiple user requests are processed by the server-side app. Don&#39;t call <code>JSRuntime.Current</code> in a component to invoke JavaScript functions.</li>
<li>Inject the <code>IJSRuntime</code> abstraction and use the injected object to issue JavaScript interop calls.</li>
</ul>
<p>The following example is based on <a href="https://developer.mozilla.org/docs/Web/API/TextDecoder">TextDecoder</a>, an experimental JavaScript-based decoder. The example demonstrates how to invoke a JavaScript function from a C# method. The JavaScript function accepts a byte array from a C# method, decodes the array, and returns the text to the component for display.</p>
<p>Inside the <code>&lt;head&gt;</code> element of <em>wwwroot/index.html</em>, provide a function that uses <code>TextDecoder</code> to decode a passed array:</p>
<pre><code class="lang-html">&lt;script&gt;
  window.ConvertArray = (win1251Array) =&gt; {
    var win1251decoder = new TextDecoder(&#39;windows-1251&#39;);
    var bytes = new Uint8Array(win1251Array);
    var decodedArray = win1251decoder.decode(bytes);
    console.log(decodedArray);
    return decodedArray;
  };
&lt;/script&gt;
</code></pre><p>JavaScript code, such as the code shown in the preceding example, can also be loaded by a JavaScript file with a reference to the script file in the <em>wwwroot/index.html</em> file.</p>
<p>The following component:</p>
<ul>
<li>Invokes the <code>ConvertArray</code> JavaScript function using <code>JsRuntime</code> when a component button (<strong>Convert Array</strong>) is selected.</li>
<li>After the JavaScript function is called, the passed array is converted into a string. The string is returned to the component for display.</li>
</ul>
<pre><code class="lang-cshtml">@page &quot;/&quot;
@using Microsoft.JSInterop;
@inject IJSRuntime JsRuntime;

&lt;h1&gt;Call JavaScript Function Example&lt;/h1&gt;

&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; onclick=&quot;@ConvertArray&quot;&gt;
    Convert Array
&lt;/button&gt;

&lt;p class=&quot;mt-2&quot; style=&quot;font-size:1.6em&quot;&gt;
    &lt;span class=&quot;badge badge-success&quot;&gt;
        @ConvertedText
    &lt;/span&gt;
&lt;/p&gt;

@functions {
    // Quote (c)2005 Universal Pictures: Serenity
    // https://www.uphe.com/movies/serenity
    // David Krumholtz on IMDB: https://www.imdb.com/name/nm0472710/

    private MarkupString ConvertedText =
        new MarkupString(&quot;Select the &lt;b&gt;Convert Array&lt;/b&gt; button.&quot;);

    private uint[] QuoteArray = new uint[]
        {
            60, 101, 109, 62, 67, 97, 110, 39, 116, 32, 115, 116, 111, 112, 32,
            116, 104, 101, 32, 115, 105, 103, 110, 97, 108, 44, 32, 77, 97,
            108, 46, 60, 47, 101, 109, 62, 32, 45, 32, 77, 114, 46, 32, 85, 110,
            105, 118, 101, 114, 115, 101, 10, 10,
        };

    async void ConvertArray()
    {
        var text =
            await JsRuntime.InvokeAsync&lt;string&gt;(&quot;ConvertArray&quot;, QuoteArray);

        ConvertedText = new MarkupString(text);

        StateHasChanged();
    }
}
</code></pre><p>For client-side Blazor apps, the <code>IJSRuntime</code> abstraction is accessible from <code>JSRuntime.Current</code>, which refers to the current user&#39;s request. Because there&#39;s only a single user of a client-side Blazor app, using <code>JSRuntime.Current</code> to invoke a JavaScript function works normally. Only use <code>JSRuntime.Current</code> in client-side Blazor apps.</p>
<p>In the client-side sample app that accompanies this topic, two JavaScript functions are available to the client-side app that interact with the DOM to receive user input and display a welcome message:</p>
<ul>
<li><code>showPrompt</code> &ndash; Produces a prompt to accept user input (the user&#39;s name) and returns the name to the caller.</li>
<li><code>displayWelcome</code> &ndash; Assigns a welcome message from the caller to a DOM object with an <code>id</code> of <code>welcome</code>.</li>
</ul>
<p><em>wwwroot/exampleJsInterop.js</em>:</p>
<pre><code class="lang-javascript" highlight-lines="2-7">window.exampleJsFunctions = {
  showPrompt: function (text) {
    return prompt(text, &#39;Type your name here&#39;);
  },
  displayWelcome: function (welcomeMessage) {
    document.getElementById(&#39;welcome&#39;).innerText = welcomeMessage;
  },
    returnArrayAsyncJs: function () {
      DotNet.invokeMethodAsync(&#39;BlazorSample&#39;, &#39;ReturnArrayAsync&#39;)
        .then(data =&gt; {
          data.push(4);
            console.log(data);
    })
  },
  sayHello: function (dotnetHelper) {
    return dotnetHelper.invokeMethodAsync(&#39;SayHello&#39;)
      .then(r =&gt; console.log(r));
  }
};
</code></pre><p>Place the <code>&lt;script&gt;</code> tag that references the JavaScript file in the <em>wwwroot/index.html</em> file:</p>
<pre><code class="lang-html" highlight-lines="16">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;
    &lt;title&gt;Blazor Sample&lt;/title&gt;
    &lt;base href=&quot;/&quot; /&gt;
    &lt;link href=&quot;css/bootstrap/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;
    &lt;link href=&quot;css/site.css&quot; rel=&quot;stylesheet&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;app&gt;Loading...&lt;/app&gt;

    &lt;script src=&quot;css/bootstrap/bootstrap-native.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;_framework/blazor.webassembly.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;exampleJsInterop.js&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>Don&#39;t place a script tag in a component file because the script tag can&#39;t be updated dynamically.</p>
<p>.NET methods interop with the JavaScript functions by calling <code>InvokeAsync&lt;T&gt;</code> method on <code>IJSRuntime</code>.</p>
<p>The sample app uses a pair of C# methods, <code>Prompt</code> and <code>Display</code>, to invoke the <code>showPrompt</code> and <code>displayWelcome</code> JavaScript functions:</p>
<p><em>JsInteropClasses/ExampleJsInterop.cs</em>:</p>
<pre><code class="lang-csharp" highlight-lines="6-8,14-16">public class ExampleJsInterop
{
    public static Task&lt;string&gt; Prompt(string text)
    {
        // showPrompt is implemented in wwwroot/exampleJsInterop.js
        return JSRuntime.Current.InvokeAsync&lt;string&gt;(
            &quot;exampleJsFunctions.showPrompt&quot;,
            text);
    }

    public static Task&lt;string&gt; Display(string welcomeMessage)
    {
        // displayWelcome is implemented in wwwroot/exampleJsInterop.js
        return JSRuntime.Current.InvokeAsync&lt;string&gt;(
            &quot;exampleJsFunctions.displayWelcome&quot;,
            welcomeMessage);
    }
    
    public static Task CallHelloHelperSayHello(string name)
    {
        // sayHello is implemented in wwwroot/exampleJsInterop.js
        return JSRuntime.Current.InvokeAsync&lt;object&gt;(
            &quot;exampleJsFunctions.sayHello&quot;,
            new DotNetObjectRef(new HelloHelper(name)));
    }
}
</code></pre><p>The <code>IJSRuntime</code> abstraction is asynchronous to allow for server-side scenarios. If the app runs client-side and you want to invoke a JavaScript function synchronously, downcast to <code>IJSInProcessRuntime</code> and call <code>Invoke&lt;T&gt;</code> instead. We recommend that most JavaScript interop libraries use the async APIs to ensure the libraries are available in all scenarios, client-side or server-side.</p>
<p>The sample app includes a component to demonstrate JS interop. The component:</p>
<ul>
<li>Receives user input via a JS prompt.</li>
<li>Returns the text to the component for processing.</li>
<li>Calls a second JS function that interacts with the DOM to display a welcome message.</li>
</ul>
<p><em>Pages/JSInterop.cshtml</em>:</p>
<pre><code class="lang-cshtml" highlight-lines="2-3,9-11,13,16-20">@page &quot;/JSInterop&quot;
@using BlazorSample.JsInteropClasses
@using Microsoft.JSInterop;

&lt;h1&gt;JavaScript Interop&lt;/h1&gt;

&lt;h2&gt;Invoke JavaScript functions from .NET methods&lt;/h2&gt;

&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; onclick=&quot;@TriggerJsPrompt&quot;&gt;
    Trigger JavaScript Prompt
&lt;/button&gt;

&lt;h3 id=&quot;welcome&quot; style=&quot;color:green;font-style:italic&quot;&gt;&lt;/h3&gt;

@functions {
    public async void TriggerJsPrompt()
    {
        var name = await ExampleJsInterop.Prompt(&quot;What&#39;s your name?&quot;);
        await ExampleJsInterop.Display($&quot;Hello {name}! Welcome to Blazor!&quot;);
    }
}
</code></pre><ol>
<li>When <code>TriggerJsPrompt</code> is executed by selecting the component&#39;s <strong>Trigger JavaScript Prompt</strong> button, the <code>ExampleJsInterop.Prompt</code> method in C# code is called.</li>
<li>The <code>Prompt</code> method executes the JavaScript <code>showPrompt</code> function provided in the <em>wwwroot/exampleJsInterop.js</em> file.</li>
<li>The <code>showPrompt</code> function accepts user input (the user&#39;s name), which is HTML-encoded and returned to the <code>Prompt</code> method and ultimately back to the component. The component stores the user&#39;s name in a local variable, <code>name</code>.</li>
<li>The string stored in <code>name</code> is incorporated into a welcome message, which is passed to a second C# method, <code>ExampleJsInterop.Display</code>.</li>
<li><code>Display</code> calls a JavaScript function, <code>displayWelcome</code>, which renders the welcome message into a heading tag.</li>
</ol>
<h2 id="capture-references-to-elements">Capture references to elements</h2>
<p>Some <a class="xref" href="javascript-interop.html">JavaScript interop</a> scenarios require references to HTML elements. For example, a UI library may require an element reference for initialization, or you might need to call command-like APIs on an element, such as <code>focus</code> or <code>play</code>.</p>
<p>You can capture references to HTML elements in a component by adding a <code>ref</code> attribute to the HTML element and then defining a field of type <code>ElementRef</code> whose name matches the value of the <code>ref</code> attribute.</p>
<p>The following example shows capturing a reference to the username input element:</p>
<pre><code class="lang-csharp">&lt;input ref=&quot;username&quot; ... /&gt;

@functions {
    ElementRef username;
}
</code></pre><div class="NOTE"><h5>Note</h5><p>Do <strong>not</strong> use captured element references as a way of populating the DOM. Doing so may interfere with the declarative rendering model.</p>
</div>
<p>As far as .NET code is concerned, an <code>ElementRef</code> is an opaque handle. The <em>only</em> thing you can do with it is pass it through to JavaScript code via JavaScript interop. When you do so, the JavaScript-side code receives an <code>HTMLElement</code> instance, which it can use with normal DOM APIs.</p>
<p>For example, the following code defines a .NET extension method that enables setting the focus on an element:</p>
<p><em>mylib.js</em>:</p>
<pre><code class="lang-javascript">window.myLib = {
  focusElement : function (element) {
    element.focus();
  }
}
</code></pre><p><em>ElementRefExtensions.cs</em>:</p>
<pre><code class="lang-csharp">using Microsoft.AspNetCore.Blazor;
using Microsoft.JSInterop;
using System.Threading.Tasks;

namespace MyLib
{
    public static class MyLibElementRefExtensions
    {
        public static Task Focus(this ElementRef elementRef)
        {
            return JSRuntime.Current.InvokeAsync&lt;object&gt;(&quot;myLib.focusElement&quot;, elementRef);
        }
    }
}
</code></pre><p>Now you can focus inputs in any of your components:</p>
<pre><code class="lang-cshtml">@using MyLib

&lt;input ref=&quot;username&quot; /&gt;
&lt;button onclick=&quot;@SetFocus&quot;&gt;Set focus&lt;/button&gt;

@functions {
    ElementRef username;

    void SetFocus()
    {
        username.Focus();
    }
}
</code></pre><div class="IMPORTANT"><h5>Important</h5><p>The <code>username</code> variable is only populated after the component renders and its output includes the <code>&lt;input&gt;</code> element. If you try to pass an unpopulated <code>ElementRef</code> to JavaScript code, the JavaScript code receives <code>null</code>. To manipulate element references after the component has finished rendering (to set the initial focus on an element) use the <code>OnAfterRenderAsync</code> or <code>OnAfterRender</code> <a class="xref" href="components/index.html#lifecycle-methods">component lifecycle methods</a>.</p>
</div>
<h2 id="invoke-net-methods-from-javascript-functions">Invoke .NET methods from JavaScript functions</h2>
<h3 id="static-net-method-call">Static .NET method call</h3>
<p>To invoke a static .NET method from JavaScript, use the <code>DotNet.invokeMethod</code> or <code>DotNet.invokeMethodAsync</code> functions. Pass in the identifier of the static method you wish to call, the name of the assembly containing the function, and any arguments. Again, the async version is preferred to support server-side scenarios. To be invokable from JavaScript, the .NET method must be public, static, and decorated with <code>[JSInvokable]</code>. By default, the method identifier is the method name, but you can specify a different identifier using the <code>JSInvokableAttribute</code> constructor. Calling open generic methods isn&#39;t currently supported.</p>
<p>The sample app includes a C# method to return an array of <code>int</code>s. The method is decorated with the <code>JSInvokable</code> attribute.</p>
<p><em>Pages/JsInterop.cshtml</em>:</p>
<pre><code class="lang-cshtml" highlight-lines="7-11">&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot;
        onclick=&quot;exampleJsFunctions.returnArrayAsyncJs()&quot;&gt;
    Trigger .NET static method ReturnArrayAsync
&lt;/button&gt;

@functions {
    [JSInvokable]
    public static Task&lt;int[]&gt; ReturnArrayAsync()
    {
        return Task.FromResult(new int[] { 1, 2, 3 });
    }
}
</code></pre><p>JavaScript served to the client invokes the C# .NET method.</p>
<p><em>wwwroot/exampleJsInterop.js</em>:</p>
<pre><code class="lang-javascript" highlight-lines="8-12">window.exampleJsFunctions = {
  showPrompt: function (text) {
    return prompt(text, &#39;Type your name here&#39;);
  },
  displayWelcome: function (welcomeMessage) {
    document.getElementById(&#39;welcome&#39;).innerText = welcomeMessage;
  },
    returnArrayAsyncJs: function () {
      DotNet.invokeMethodAsync(&#39;BlazorSample&#39;, &#39;ReturnArrayAsync&#39;)
        .then(data =&gt; {
          data.push(4);
            console.log(data);
    })
  },
  sayHello: function (dotnetHelper) {
    return dotnetHelper.invokeMethodAsync(&#39;SayHello&#39;)
      .then(r =&gt; console.log(r));
  }
};
</code></pre><p>When the <strong>Trigger .NET static method ReturnArrayAsync</strong> button is selected, examine the console output in the browser&#39;s web developer tools:</p>
<pre><code class="lang-console">Array(4) [ 1, 2, 3, 4 ]
</code></pre><p>The fourth array value is pushed to the array (<code>data.push(4);</code>) returned by <code>ReturnArrayAsync</code>.</p>
<h3 id="instance-method-call">Instance method call</h3>
<p>You can also call .NET instance methods from JavaScript. To invoke a .NET instance method from JavaScript, first pass the .NET instance to JavaScript by wrapping it in a <code>DotNetObjectRef</code> instance. The .NET instance is passed by reference to JavaScript, and you can invoke .NET instance methods on the instance using the <code>invokeMethod</code> or <code>invokeMethodAsync</code> functions. The .NET instance can also be passed as an argument when invoking other .NET methods from JavaScript.</p>
<div class="NOTE"><h5>Note</h5><p>The sample app logs messages to the client-side console. For the following examples demonstrated by the sample app, examine the browser&#39;s console output in the browser&#39;s developer tools.</p>
</div>
<p>When the <strong>Trigger .NET instance method HelloHelper.SayHello</strong> button is selected, <code>ExampleJsInterop.CallHelloHelperSayHello</code> is called and passes a name, <code>Blazor</code>, to the method.</p>
<p><em>Pages/JsInterop.cshtml</em>:</p>
<pre><code class="lang-cshtml" highlight-lines="8">&lt;button type=&quot;button&quot; class=&quot;btn btn-primary&quot; onclick=&quot;@TriggerNetInstanceMethod&quot;&gt;
    Trigger .NET instance method HelloHelper.SayHello
&lt;/button&gt;

@functions {
    public async void TriggerNetInstanceMethod()
    {
        await ExampleJsInterop.CallHelloHelperSayHello(&quot;Blazor&quot;);
    }
}
</code></pre><p><code>CallHelloHelperSayHello</code> invokes the JavaScript function <code>sayHello</code> with a new instance of <code>HelloHelper</code>.</p>
<p><em>JsInteropClasses/ExampleJsInterop.cs</em>:</p>
<pre><code class="lang-csharp" highlight-lines="19-25">public class ExampleJsInterop
{
    public static Task&lt;string&gt; Prompt(string text)
    {
        // showPrompt is implemented in wwwroot/exampleJsInterop.js
        return JSRuntime.Current.InvokeAsync&lt;string&gt;(
            &quot;exampleJsFunctions.showPrompt&quot;,
            text);
    }

    public static Task&lt;string&gt; Display(string welcomeMessage)
    {
        // displayWelcome is implemented in wwwroot/exampleJsInterop.js
        return JSRuntime.Current.InvokeAsync&lt;string&gt;(
            &quot;exampleJsFunctions.displayWelcome&quot;,
            welcomeMessage);
    }
    
    public static Task CallHelloHelperSayHello(string name)
    {
        // sayHello is implemented in wwwroot/exampleJsInterop.js
        return JSRuntime.Current.InvokeAsync&lt;object&gt;(
            &quot;exampleJsFunctions.sayHello&quot;,
            new DotNetObjectRef(new HelloHelper(name)));
    }
}
</code></pre><p><em>wwwroot/exampleJsInterop.js</em>:</p>
<pre><code class="lang-javascript" highlight-lines="15-17">window.exampleJsFunctions = {
  showPrompt: function (text) {
    return prompt(text, &#39;Type your name here&#39;);
  },
  displayWelcome: function (welcomeMessage) {
    document.getElementById(&#39;welcome&#39;).innerText = welcomeMessage;
  },
    returnArrayAsyncJs: function () {
      DotNet.invokeMethodAsync(&#39;BlazorSample&#39;, &#39;ReturnArrayAsync&#39;)
        .then(data =&gt; {
          data.push(4);
            console.log(data);
    })
  },
  sayHello: function (dotnetHelper) {
    return dotnetHelper.invokeMethodAsync(&#39;SayHello&#39;)
      .then(r =&gt; console.log(r));
  }
};
</code></pre><p>The name is passed to <code>HelloHelper</code>&#39;s constructor, which sets the <code>HelloHelper.Name</code> property. When the JavaScript function <code>sayHello</code> is executed, <code>HelloHelper.SayHello</code> returns the <code>Hello, {Name}!</code> message, which is written to the console by the JavaScript function.</p>
<p><em>JsInteropClasses/HelloHelper.cs</em>:</p>
<pre><code class="lang-csharp" highlight-lines="5,10-11">public class HelloHelper
{
    public HelloHelper(string name)
    {
        Name = name;
    }

    public string Name { get; set; }

    [JSInvokable]
    public string SayHello() =&gt; $&quot;Hello, {Name}!&quot;;
}
</code></pre><p>Console output in the browser&#39;s web developer tools:</p>
<pre><code class="lang-console">Hello, Blazor!
</code></pre><h2 id="share-interop-code-in-a-razor-component-class-library">Share interop code in a Razor Component class library</h2>
<p>JavaScript interop code can be included in a Razor Component class library (<code>dotnet new blazorlib</code>), which allows you to share the code in a NuGet package.</p>
<p>The Razor Component class library handles embedding JavaScript resources in the built assembly. The JavaScript files are placed in the <em>wwwroot</em> folder, and the tooling takes care of embedding the resources when the library is built.</p>
<p>The built NuGet package is referenced in the project file of the app just as any normal NuGet package is referenced. After the app has been restored, app code can call into JavaScript as if it were C#.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/aspnet/Blazor.Docs/blob/master/docs/javascript-interop.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../styles/docfx.js"></script>
    <script type="text/javascript" src="../styles/main.js"></script>
  </body>
</html>
